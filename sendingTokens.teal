//check that the transaction group contains exactly two transactions
//Push the result of this check to the stack
global GroupSize
int 2
==
//check that the first transaction is a payment
//fold the result of this check into the previous one with a logical AND
gtxn 0 TypeEnum
int 1
==
&&
// specify that the receiver of funds from the first transaction is equal to the sender of the second transaction
gtxn 0 Receiver
txn Sender
==
&&
// check that the first transaction's amount is equal to the fee of the second transaction
gtxn 0 Amount
txn Fee
==
&&
// check that the group is laid out as expected. If you don't do this, a contract might be tricked into serving multiple, unexpected roles within the group.
txn GroupIndex
int 1
==
&&
//Check that the second transaction is a payment.
txn TypeEnum
int 1
==
&&
//Finally, check that all of the fields in the 
//second transaction are equal to their corresponding contract parameters.
//Fold all of these checks into a single boolean.
// txn Receiver
// addr TMPL_TO
// ==
// &&
// txn CloseRemainderTo
// addr TMPL_CLS
// ==
// &&
// txn Amount
// int TMPL_AMT
// ==
// &&
// txn FirstValid
// int TMPL_FV
// ==
// &&
// txn LastValid
// int TMPL_LV
// ==
// &&
// txn Lease
// byte base64 TMPL_LEASE
// ==
// &&
//At this point, the stack contains just one value: a boolean indicating whether or not the transaction has been approved by this contract.
